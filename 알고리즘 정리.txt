1. 브루트포스 알고리즘
- 1) 범위가 작고, 정해져있다면 모든 경로 탐색해보기
- 2) 색깔 칠하기 같은 경우, 기본 값을 만들어두고, 그 값과 탐색값을 비교하면서 체크하기.

2. 소수 찾기
1) isPrime 함수 이용하기
2) 에라토스테네스의 체
방법
2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.
2는 소수이므로 오른쪽에 2를 쓴다.
자기 자신을 제외한 2의 배수를 모두 지운다.
남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다.
자기 자신을 제외한 3의 배수를 모두 지운다.

3. 백트래킹
- 해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 다시 해를 찾아가는 기법.

4. dfs(깊이 우선 탐색)
- 스택이나 재귀함수 이용
1) 탐색 시작 노드를 스택에 삽입하고 방문 처리
2) 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리. 
방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄.
3) 더 이상 2번의 과정을 수행할 수 없을 때까지 반복.

5. BFS(넓이 우선 탐색)
- queue 이용
1) 탐색 시작 노드를 queue에 삽입하고 방문처리
2) queue가 비어있는 상태가 될 때까지 아래를 반복
  2-1) queue의 맨 처음 노드를 꺼냄. 
  2-2) 꺼낸 노드와 인접한 노드들의 방문여부와 방문 가능한지 확인.
  2-3) 만약 도착 지점이 아니라면 방문한 노드를 방문처리 후, 해당 좌표를 queue에 넣음.
  2-4) 중간에 도착 지점을 만나게 되면 해당 좌표를 리턴.

6. DP(동적계획법)
- 이미 했던 연산이 반복되는 결점을 보완하기 위해 사용.
- 재귀에서 반복되던 연산을 없앤 알고리즘.
- 한번 계산된 결과를 저장해두었다가 활용하는 방식으로 중복 계산을 줄이는 것을 메모이제이션이라 함.
- TOP-DOWN 이나 BOTTOM-UP 방식을 사용.
-> TOP-DOWN은 큰수부터 작은 수 순서로, BOTTOM-UP은 반대.

** 기존 값에 연산한 값을 추가로 연산하여 저장한다!!

7. 누적합
- 누적합 배열을 만든다. 기존 배열보다 하나씩 크게 만든다.
ex) [1,2,3,4,5] => [0,1,3,6,10,15]
- 이후 설정된 구간에서 필요없는 구간을 뺀다.
ex) 2~4 구간의 누적합을 구하시오. arr[4] - arr[2-1] = 10 - 1 = 9

8. Greedy (탐욕법)
- 각 단계에서 가장 최선의 선택을 하는 기법.
- 대부분 최소값을 찾거나, 최대값을 찾거나 어떤 값을 찾는 방식의 문제로 나옴.
- 그렇기 떄문에 정렬 sort() 메서드를 이용하여 배열을 정렬한 후에 문제를 해결할 것.
- 백준의 1541 잃어버린 괄호의 경우, 덧셈을 먼저 진행한 후 뺄셈을 진행함.
- 이와 같이 어떤 방식으로 먼저 계산할 것인지를 확인하는 것도 좋음.

9. 유클리드 호제법
- 최대공약수와 최소공배수를 구할 때 사용한다.
- 기본원리는 num1 를 num2로 나눈 나머지를 r 이라고 했을 때, 
gcd(num1, num2) = gcd(num2, r)  원리이다.
ex) gcd(24,16) = gcd(16, 8) = gcd(8, 0) , gcd = 8;
- 최소공배수는 최대공약수를 응용하여 구할 수 있다.
num1 * num2 = gcd * lcm 을 이용한 원리이다.
lcm = (num1 * num2) / gcd
-------------------

자료 구조
1. 스택 : 후입 선출
- push() : 가장 위에 데이터 넣기
- pop() : 가장 위에 있는 데이터 꺼내기